options {
    LOOKAHEAD = 1;
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Parser)
package yapl.compiler;
import yapl.interfaces.CompilerError;
import yapl.lib.CompilerMessage;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import yapl.symbol.*;
import yapl.lib.*;

/** CA2.3 */
public class Parser {

    private static String programName = "";
    private static Symboltable symboltable = new Symboltable();

  /** Main entry point. */
  public static void main(String args[]) {

        if(args.length < 1){
            System.out.println("Not enough arguments! Please enter file path.");
            return;
        }
        try{
            Parser parser = new Parser(new FileInputStream(args[0]));
            parser.Program();
            CompilerMessage.printOK(programName);
        } catch (ParseException e) {
            CompilerMessage.printError(e, programName);
        } catch(TokenMgrError e) {
            CompilerMessage.printError(e, programName);
        }catch (YAPLException e){
            CompilerMessage.printError(e, programName);
        } catch(Exception e){
            e.printStackTrace();
        }
   }
}

PARSER_END(Parser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
 <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

void Program() throws YAPLException:
{
        Token t, endIdent;
}
{
    {
        symboltable.openScope(true);

        Symbol pp1 = new Symbol(Symbol.PredefinedProcedure, "writeint", 0, 0);
                Symbol pp1p = new Symbol(Symbol.Parameter, "i", 0, 0);

                Symbol pp2 = new Symbol(Symbol.PredefinedProcedure, "writebool", 0, 0);
                Symbol pp2p = new Symbol(Symbol.Parameter, "b", 0, 0);

                Symbol pp3 = new Symbol(Symbol.PredefinedProcedure, "writeln", 0, 0);

                Symbol pp4 = new Symbol(Symbol.PredefinedProcedure, "readint", 0, 0);

                symboltable.addSymbol(pp1);
                symboltable.addSymbol(pp1p);
                symboltable.addSymbol(pp2);
                symboltable.addSymbol(pp2p);
                symboltable.addSymbol(pp3);
                symboltable.addSymbol(pp4);
    }
    "Program" t = <ident>
    {
        symboltable.openScope(true);

        Symbol s = new Symbol(Symbol.Program, t.image, t.beginLine, t.beginColumn);
        symboltable.setParentSymbol(s);
        symboltable.addSymbol(s);
        programName = t.toString();
        symboltable.openScope(true);

    }
    ( Decl() | Procedure())*
    "Begin"  StatementList() "End" endIdent = <ident>
    {
        if(!programName.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match program " + programName, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
        symboltable.closeScope();
    }
    "." <EOF>


}


//Decls
void Decl() throws YAPLException:
{
}
{
    "Declare" ( ConstDecl() | VarDecl() | TypeDecl() ) *
}

void ConstDecl() throws YAPLException:
{
     Token t;
}
{
    "Const" t = <ident> "=" Literal() ";"
    {
        Symbol s = new Symbol(Symbol.Constant, t.image, t.beginLine, t.beginColumn);
                    Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
                    if(checkedSymbol != null) {
                                                throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
                    }
                    symboltable.addSymbol((yapl.symbol.Symbol)s);
                    }
}

void VarDecl() throws YAPLException:
{
    Token t, u;
}
{
    Type() t = <ident>
    {
                                   Symbol s = new Symbol(Symbol.Variable, t.image, t.beginLine, t.beginColumn);
                                   Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
                                   if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
                                   symboltable.addSymbol((yapl.symbol.Symbol)s);
                                   //symbol 'k' already declared in current scope (as variable)

    }
    ("," u = <ident>
    {
        Symbol v = new Symbol(Symbol.Variable, u.image, u.beginLine, u.beginColumn);
                                Symbol checkedSymbol2 = (yapl.symbol.Symbol)symboltable.lookup(u.image, u.beginLine, u.beginColumn);
                                if(checkedSymbol2 != null) throw new YAPLException("Identifier '" + u.image + "' already declared in current scope (as " + checkedSymbol2.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, u.beginLine, u.beginColumn);
                                symboltable.addSymbol((yapl.symbol.Symbol)v);
    })* ";"
}

void TypeDecl() throws YAPLException:
{
    Token t;
}
{
    "Record" t = <ident>
     {
                 Symbol s = new Symbol(Symbol.Typename, t.image, t.beginLine, t.beginColumn);
                             Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
                             if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
                             System.out.println("Before adding symbol: " + s.getName());
                             symboltable.addSymbol((yapl.symbol.Symbol)s);
                             symboltable.openScope(false);
         }
     VarDecl() (VarDecl())* "EndRecord" {symboltable.closeScope();} ";"

}
//________________END OF DECs___________

//________________TYPEs_____________

void NonArrayType() throws YAPLException:
{
       Token t;
}
{
    "int" | "bool" |
    t = <ident> {

                                             Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
                                             Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                                             System.out.println("Lookup finished");
                                             if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                                              if(checkedSymbol != null){
                                                  if(checkedSymbol.getKindString() != null){
                                                      if(checkedSymbol.getKind() != Symbol.Typename) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                                                  }
                                              }symboltable.addSymbol(s);}
}


void Type() throws YAPLException:
{
}
{
    NonArrayType() ("[""]")*
}

void ReturnType() throws YAPLException:
{
}
{
    "void" | Type()
}
//________________END OF TYPEs________

//________________PROCEDUREs__________
void Procedure() throws YAPLException:
{
            Token t, endIdent;
}
{
    "Procedure" ReturnType() t = <ident>
    {
        Symbol s = new Symbol(Symbol.Procedure, t.image, t.beginLine, t.beginColumn);
        symboltable.addSymbol(s);
        symboltable.setParentSymbol(s);
        symboltable.openScope(false);
    }
    "(" (FormalParamList())? ")" Block() endIdent = <ident> ";"
    {
        if(!t.image.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match procedure " + t.image, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
    }
}

void FormalParamList() throws YAPLException:
{
}
{
    {System.out.println("Formal Paramlist incoming");}
     FormalParam() ("," FormalParam())*
}

void FormalParam() throws YAPLException:
{
    Token t;
}
{
    Type() t = <ident>
    {
                Symbol s = new Symbol(Symbol.Parameter, t.image, t.beginLine, t.beginColumn);
                            symboltable.addSymbol((yapl.symbol.Symbol)s);        }
}
//________________END OF PROCEDUREs____

//________________STATEMENTs___________

void StatementList() throws YAPLException:
{
}
{
    (Statement() ";")*
}

void Statement() throws YAPLException:
{
}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() | LOOKAHEAD(2) ProcedureCall() | Block()
}

void WriteStatement() throws YAPLException:
{
}
{
    "Write" <string>
}

void ReturnStatement() throws YAPLException:
{
}
{
    "Return" (Expr())?
}

void WhileStatement() throws YAPLException:
{
}
{
    "While" Expr() "Do" StatementList() "EndWhile"
}

void IfStatement() throws YAPLException:
{
}
{
    "If" Expr() "Then" StatementList() ("Else" StatementList())? "EndIf"
}

void Assignment() throws YAPLException:
{
    Token t;
}
{
   t = <ident> (Selector())? ":=" Expr()
   {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        //symbol 'k' already declared in current scope (as variable)
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        if(checkedSymbol.getKind() == (Symbol.Constant)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
        symboltable.addSymbol(s);
   }
}

void ProcedureCall() throws YAPLException:
{
    Token t;
}
{
    t = <ident> "(" (ArgumentList())? ")"
    {
            Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
            Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
            //symbol 'k' already declared in current scope (as variable)
            if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
            if(!(checkedSymbol.getKind() == Symbol.Procedure || checkedSymbol.getKind() == Symbol.PredefinedProcedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
            //symboltable.addSymbol(s);
       }
}

void ArgumentList() throws YAPLException:
{
}
{
    Expr() ("," Expr())*
}

void Block() throws YAPLException:
{
}
{
    {symboltable.openScope(false);}
    (Decl())? "Begin" StatementList() "End"
    {symboltable.closeScope();}
}
//________________END OF STATEMENTs_____

//_______________EXPRESSIONs________

void Expr() throws YAPLException:
{
}
{
    CondAndExpr() ("Or" CondAndExpr())* | CreationExpr()
}

void CreationExpr() throws YAPLException:
{
}
{
    "new" NonArrayType() ("[" Expr() "]")*
}

void CondAndExpr() throws YAPLException:
{
}
{
    EqualExpr() ("And" EqualExpr())*
}

void EqualExpr() throws YAPLException:
{
}
{
    RelExpr() (EqualOp() RelExpr())?
}

void RelExpr() throws YAPLException:
{
}
{
    AddExpr() (RelOp() AddExpr())?
}

void AddExpr() throws YAPLException:
{
}
{
    MulExpr() (AddOp() MulExpr())*
}


void MulExpr() throws YAPLException:
{
}
{
    UnaryExpr() (MulOp() UnaryExpr())*
}

void UnaryExpr() throws YAPLException:
{
}
{
    (AddOp())? PrimaryExpr()
}

void PrimaryExpr() throws YAPLException:
{
  Token t;
}
{
    Literal() | "(" Expr() ")" | LOOKAHEAD (2) ProcedureCall() | t = <ident>

    {

                Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);

                Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                System.out.println("Symbol to check: " + t.image + " of kind: " + t.kind);
                System.out.println("Checked symbol: " + checkedSymbol.getName());
                if(checkedSymbol.getKindString() != null){
                    if(!(checkedSymbol.getKind() == Symbol.Variable || checkedSymbol.getKind() == Symbol.Constant || checkedSymbol.getKind() == Symbol.Parameter)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " '" + checkedSymbol.getName() + "'", CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                }
        }

    (Selector())?


    | ArrayLen()
}

void ArrayLen() throws YAPLException:
{
Token t;
}
{
    "#" t = <ident> (Selector())?
    {

                Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
                Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                if(checkedSymbol.getKind() == (Symbol.Constant) || checkedSymbol.getKind() == (Symbol.Procedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                }
}

void Selector() throws YAPLException:
{
}
{
    ( "[" Expr()  "]" | "." <ident> ) (Selector())?
}

void Literal() throws YAPLException:
{
}
{
    "True" | "False" | <number>
}
//_______________END OF EXPRESSIONs____

//__________________OPs_______________
void RelOp() throws YAPLException:
{
}
{
    "<" | "<=" | ">=" | ">"
}

void EqualOp() throws YAPLException:
{
}
{
    "==" | "!="
}

void AddOp() throws YAPLException:
{
}
{
    "+" | "-"
}

void MulOp() throws YAPLException:
{
}
{
    "*" | "/" | "%"
}
//________________END OF OPs___________


TOKEN : /* LITERALS */
{

    <ident: <letter> ( <letter> | <digit> )*>
|
    <number: <digit> ( <digit> )*>
|
    <string:"\"" ( " " | <letter> | <digit> | <otherchar> )* "\"">
|
     <digit: ["0"-"9"] >
|
    <letter: ["A"-"Z"]|["a"-"z"]|"_">
|
    <otherchar:"+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
                         | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
                         | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|">
}
