options {
    LOOKAHEAD = 1;
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Parser)
package yapl.compiler;
import yapl.interfaces.CompilerError;
import yapl.lib.CompilerMessage;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import yapl.symbol.*;
import yapl.lib.*;

/** CA2.3 */
public class Parser {

    private static String programName = "";
    private static Symboltable symboltable = new Symboltable();
    private static CodeGen cg = new CodeGen();

  /** Main entry point. */
  public static void main(String args[]) {

        if(args.length < 1){
            System.out.println("Not enough arguments! Please enter file path.");
            return;
        }
        try{
            Parser parser = new Parser(new FileInputStream(args[0]));
            parser.Program();
            CompilerMessage.printOK(programName);
        } catch (ParseException e) {
            CompilerMessage.printError(e, programName);
        } catch(TokenMgrError e) {
            CompilerMessage.printError(e, programName);
        }catch (YAPLException e){
            CompilerMessage.printError(e, programName);
        } catch(Exception e){
            e.printStackTrace();
        }
   }
}

PARSER_END(Parser)

/*
#################################
###### TYPE CHECKING ORDER ######
#################################

1) Expressions
2) Assignments
3) Procedure Declarations
4) Procedure Calls
5) Other Statements



 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
 <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

void Program() throws YAPLException:
{
        Token t, endIdent;
}
{
    {
        symboltable.openScope(true);

        Symbol pp1 = new Symbol(Symbol.PredefinedProcedure, "writeint", 0, 0);
                Symbol pp1p = new Symbol(Symbol.Parameter, "i", 0, 0);

                Symbol pp2 = new Symbol(Symbol.PredefinedProcedure, "writebool", 0, 0);
                Symbol pp2p = new Symbol(Symbol.Parameter, "b", 0, 0);

                Symbol pp3 = new Symbol(Symbol.PredefinedProcedure, "writeln", 0, 0);

                Symbol pp4 = new Symbol(Symbol.PredefinedProcedure, "readint", 0, 0);

                symboltable.addSymbol(pp1);
                symboltable.addSymbol(pp1p);
                symboltable.addSymbol(pp2);
                symboltable.addSymbol(pp2p);
                symboltable.addSymbol(pp3);
                symboltable.addSymbol(pp4);
    }
    "Program" t = <ident>
    {
        symboltable.openScope(true);

        Symbol s = new Symbol(Symbol.Program, t.image, t.beginLine, t.beginColumn);
        symboltable.setParentSymbol(s);
        symboltable.addSymbol(s);
        programName = t.toString();
        symboltable.openScope(true);

    }
    ( Decl() | Procedure())*
    "Begin"  StatementList() "End" endIdent = <ident>
    {
        if(!programName.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match program " + programName, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
        symboltable.closeScope();
    }
    "." <EOF>


}


//Decls
void Decl() throws YAPLException:
{
}
{
    "Declare" ( ConstDecl() | VarDecl() | TypeDecl() ) *
}

void ConstDecl() throws YAPLException:
{
     Token t;
}
{
    "Const" t = <ident> "=" Literal() ";"
    {
        Symbol s = new Symbol(Symbol.Constant, t.image, t.beginLine, t.beginColumn);
                    Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
                    if(checkedSymbol != null) {
                                                throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
                    }
                    symboltable.addSymbol((yapl.symbol.Symbol)s);
                    }
}

void VarDecl() throws YAPLException:
{
    Token t, u;
    Type type;
}
{
    type = Type() t = <ident>
    {
                                   Symbol s = new Symbol(Symbol.Variable, t.image, t.beginLine, t.beginColumn);
                                   s.setType(type);
                                   Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
                                   if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
                                   symboltable.addSymbol((yapl.symbol.Symbol)s);
                                   //symbol 'k' already declared in current scope (as variable)

    }
    ("," u = <ident>
    {
        Symbol v = new Symbol(Symbol.Variable, u.image, u.beginLine, u.beginColumn);
                                Symbol checkedSymbol2 = (yapl.symbol.Symbol)symboltable.lookup(u.image, u.beginLine, u.beginColumn);
                                if(checkedSymbol2 != null) throw new YAPLException("Identifier '" + u.image + "' already declared in current scope (as " + checkedSymbol2.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, u.beginLine, u.beginColumn);
                                symboltable.addSymbol((yapl.symbol.Symbol)v);
    })* ";"
}

void TypeDecl() throws YAPLException:
{
    Token t;
}
{
    "Record" t = <ident>
     {
                 Symbol s = new Symbol(Symbol.Typename, t.image, t.beginLine, t.beginColumn);
                             Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
                             if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
                             System.out.println("Before adding symbol: " + s.getName());
                             symboltable.addSymbol((yapl.symbol.Symbol)s);
                             symboltable.openScope(false);
         }
     VarDecl() (VarDecl())* "EndRecord" {symboltable.closeScope();} ";"

}
//________________END OF DECs___________

//________________TYPEs_____________

Type NonArrayType() throws YAPLException:
{
       Token t;
}
{
    "int" {
                return new IntegerType();
        } |
 "bool" {return new BooleanType();} |
    t = <ident> {

                                             Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
                                             Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                                             System.out.println("Lookup finished");
                                             if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                                              if(checkedSymbol != null){
                                                  if(checkedSymbol.getKindString() != null){
                                                      if(checkedSymbol.getKind() != Symbol.Typename) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                                                  }
                                              }symboltable.addSymbol(s);}
                     {return new RecordType(t.image);}
}


Type Type() throws YAPLException:
{
       Type type;
}
{
    type = NonArrayType() ("[""]")*
    {return type;}
}

Type ReturnType() throws YAPLException:
{
    Type type;
}
{
    "void" {return new VoidType();} | type = Type() {return type;}
}
//________________END OF TYPEs________

//________________PROCEDUREs__________
void Procedure() throws YAPLException:
{
            Token t, endIdent;
}
{
    "Procedure" ReturnType() t = <ident>
    {
        Symbol s = new Symbol(Symbol.Procedure, t.image, t.beginLine, t.beginColumn);
        symboltable.addSymbol(s);
        symboltable.setParentSymbol(s);
        symboltable.openScope(false);
    }
    "(" (FormalParamList())? ")" Block() endIdent = <ident> ";"
    {
        if(!t.image.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match procedure " + t.image, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
    }
}

void FormalParamList() throws YAPLException:
{
}
{
    {System.out.println("Formal Paramlist incoming");}
     FormalParam() ("," FormalParam())*
}

void FormalParam() throws YAPLException:
{
    Token t;
    Type type;
}
{
    type = Type() t = <ident>
    {
                Symbol s = new Symbol(Symbol.Parameter, t.image, t.beginLine, t.beginColumn);
                s.setType(type);
                symboltable.addSymbol((yapl.symbol.Symbol)s);        }
}
//________________END OF PROCEDUREs____

//________________STATEMENTs___________

void StatementList() throws YAPLException:
{
}
{
    (Statement() ";")*
}

void Statement() throws YAPLException:
{
}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() | LOOKAHEAD(2) ProcedureCall() | Block()
}

void WriteStatement() throws YAPLException:
{
}
{
    "Write" <string>
}

void ReturnStatement() throws YAPLException:
{
}
{
    "Return" (Expr())?
}

void WhileStatement() throws YAPLException:
{
}
{
    "While" Expr() "Do" StatementList() "EndWhile"
}

void IfStatement() throws YAPLException:
{
}
{
    "If" Expr() "Then" StatementList() ("Else" StatementList())? "EndIf"
}

void Assignment() throws YAPLException:
{
    Token t;
}
{
   t = <ident> (Selector())? ":=" Expr()
   {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        //symbol 'k' already declared in current scope (as variable)
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        if(checkedSymbol.getKind() == (Symbol.Constant)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
        symboltable.addSymbol(s);
   }
}

void ProcedureCall() throws YAPLException:
{
    Token t;
}
{
    t = <ident> "(" (ArgumentList())? ")"
    {
            Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
            Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
            //symbol 'k' already declared in current scope (as variable)
            if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
            if(!(checkedSymbol.getKind() == Symbol.Procedure || checkedSymbol.getKind() == Symbol.PredefinedProcedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
            //symboltable.addSymbol(s);
       }
}

void ArgumentList() throws YAPLException:
{
}
{
    Expr() ("," Expr())*
}

void Block() throws YAPLException:
{
}
{
    {symboltable.openScope(false);}
    (Decl())? "Begin" StatementList() "End"
    {symboltable.closeScope();}
}
//________________END OF STATEMENTs_____

//_______________EXPRESSIONs________

Attrib Expr() throws YAPLException:
{
}
{
    CondAndExpr() ("Or" CondAndExpr())* | CreationExpr()
    {
        return new Attrib();
    }
}

Attrib CreationExpr() throws YAPLException:
{
        Type type;
}
{
    "new" type = NonArrayType() ("[" Expr() "]")*
    {return new Attrib();}
}

Attrib CondAndExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = EqualExpr() ("And" expr2 = EqualExpr()
    {
        operator = new Token();
        operator.image = "And";
        return cg.op2(expr1, token, expr2);
    }
    )*

    {return expr1;}
}

Attrib EqualExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = RelExpr() (operator = EqualOp() expr2 = RelExpr()
    {
        return cg.equalOp(expr1, operator, expr2);
    }
    )?

    {return expr1;}
}

Attrib RelExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = AddExpr() (operator = RelOp() expr2 = AddExpr()
    {
        return cg.relOp(expr1, operator, expr2);
    }
    )?

    {return expr1;}
}

Attrib AddExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = MulExpr() (operator = AddOp() expr2 = MulExpr()
    {
        return cg.op2(expr1, operator, expr2);
    }
    )*

    {return expr1;}
}


Attrib MulExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = UnaryExpr() (operator = MulOp() expr2 = UnaryExpr()
    {
        return cg.op2(expr1, operator, expr2);
    }
    )*

    {return expr1;}
}

Attrib UnaryExpr() throws YAPLException:
{
   Attrib expr;
   Token operator = null;
}
{
    (operator = AddOp())? expr = PrimaryExpr()
    {
        return cg.op1(operator, expr);
    }
}

Attrib PrimaryExpr() throws YAPLException:
{
  Token t;
  Attrib attrib = null;
}
{
    attrib = Literal() {return attrib;} | "(" attrib = Expr() {return attrib;} ")" | LOOKAHEAD (2) ProcedureCall() | t = <ident>

    {

                Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);

                Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                System.out.println("Symbol to check: " + t.image + " of kind: " + t.kind);
                System.out.println("Checked symbol: " + checkedSymbol.getName());
                if(checkedSymbol.getKindString() != null){
                    if(!(checkedSymbol.getKind() == Symbol.Variable || checkedSymbol.getKind() == Symbol.Constant || checkedSymbol.getKind() == Symbol.Parameter)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " '" + checkedSymbol.getName() + "'", CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                }
        }

    (Selector())? | ArrayLen()
    {
        return attrib;
    }
}

void ArrayLen() throws YAPLException:
{
Token t;
}
{
    "#" t = <ident> (Selector())?
    {

                Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
                System.out.println("Kind: " + t.kind);
                Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                if(checkedSymbol.getKind() == (Symbol.Constant) || checkedSymbol.getKind() == (Symbol.Procedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                }
}

void Selector() throws YAPLException:
{
}
{
    ( "[" Expr()  "]" | "." <ident> ) (Selector())?
}

Attrib Literal() throws YAPLException:
{
       Attrib attrib;
}
{
    "True" {return new Attrib(new BooleanType());} | "False" {return new Attrib(new BooleanType());} | <number> {return new Attrib(new IntegerType());}
}
//_______________END OF EXPRESSIONs____

//__________________OPs_______________
Token RelOp() throws YAPLException:
{
            Token token;
}
{
    token = "<" | token = "<=" | token = ">=" | token = ">"
    {
            return token;
        }
}

Token EqualOp() throws YAPLException:
{
    Token token;
}
{
    token = "==" | token = "!="
    {
        return token;
    }
}

Token AddOp() throws YAPLException:
{
            Token token;
}
{
    token = "+" | token = "-"
    {
            return token;
        }
}

Token MulOp() throws YAPLException:
{
            Token token;
}
{
    token = "*" | token = "/" | token = "%"
    {
            return token;
        }
}
//________________END OF OPs___________


TOKEN : /* LITERALS */
{

    <ident: <letter> ( <letter> | <digit> )*>
|
    <number: <digit> ( <digit> )*>
|
    <string:"\"" ( " " | <letter> | <digit> | <otherchar> )* "\"">
|
     <digit: ["0"-"9"] >
|
    <letter: ["A"-"Z"]|["a"-"z"]|"_">
|
    <otherchar:"+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
                         | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
                         | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|">
}
