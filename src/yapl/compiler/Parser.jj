options {
    LOOKAHEAD = 1;
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Parser)
package yapl.compiler;
import yapl.interfaces.CompilerError;
import yapl.lib.CompilerMessage;
import java.io.FileInputStream;
import yapl.symbol.*;
import yapl.lib.*;

/** CA2.3 */
public class Parser {

    private static String programName = "";
    private static Symboltable symboltable = new Symboltable();
    private static CodeGen cg = new CodeGen();

  /** Main entry point. */
  public static void main(String args[]) {

        if(args.length < 1){
            System.out.println("Not enough arguments! Please enter file path.");
            return;
        }
        try{
            Parser parser = new Parser(new FileInputStream(args[0]));
            parser.Program();
            CompilerMessage.printOK(programName);
        } catch (ParseException e) {
            CompilerMessage.printError(e, programName);
        } catch(TokenMgrError e) {
            CompilerMessage.printError(e, programName);
        }catch (YAPLException e){
            CompilerMessage.printError(e, programName);
        } catch(Exception e){
            e.printStackTrace();
        }
   }
}

PARSER_END(Parser)

/*
#################################
###### TYPE CHECKING ORDER ######
#################################

1) Expressions
2) Assignments
3) Procedure Declarations
4) Procedure Calls
5) Other Statements



 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
 <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

void Program() throws YAPLException:
{
        Token t, endIdent;
}
{
    {
        symboltable.openScope(true);

        /*Symbol pp1 = new Symbol(Symbol.PredefinedProcedure, "writeint", 0, 0);
                Symbol pp1p = new Symbol(Symbol.Parameter, "i", 0, 0);

                Symbol pp2 = new Symbol(Symbol.PredefinedProcedure, "writebool", 0, 0);
                Symbol pp2p = new Symbol(Symbol.Parameter, "b", 0, 0);

                Symbol pp3 = new Symbol(Symbol.PredefinedProcedure, "writeln", 0, 0);

                Symbol pp4 = new Symbol(Symbol.PredefinedProcedure, "readint", 0, 0);

                symboltable.addSymbol(pp1);
                symboltable.addSymbol(pp1p);
                symboltable.addSymbol(pp2);
                symboltable.addSymbol(pp2p);
                symboltable.addSymbol(pp3);
                symboltable.addSymbol(pp4);*/
    }
    "Program" t = <ident>
    {
        symboltable.openScope(true);

        Symbol s = new Symbol(Symbol.Program, t.image, t.beginLine, t.beginColumn);
        symboltable.setParentSymbol(s);
        symboltable.addSymbol(s);
        programName = t.toString();
        symboltable.openScope(true);

    }
    ( Decl() | Procedure())*
    "Begin"  StatementList() "End" endIdent = <ident>
    {
        if(!programName.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match program " + programName, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
        symboltable.closeScope();
    }
    "." <EOF>


}


//Decls
void Decl() throws YAPLException:
{
}
{
    "Declare" ( ConstDecl() | VarDecl() | TypeDecl() ) *
}

void ConstDecl() throws YAPLException:
{
     Token t;
     Attrib attrib;
}
{
    "Const" t = <ident> "=" attrib = Literal() ";"
    {
        Symbol s = new Symbol(Symbol.Constant, t.image, t.beginLine, t.beginColumn);
        s.setType(attrib.getType());
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
        if(checkedSymbol != null) {
            throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
        }
        symboltable.addSymbol((yapl.symbol.Symbol)s);
        }
}

void VarDecl() throws YAPLException:
{
    Token t, u;
    Type type;
}
{
    type = Type() t = <ident>
    {
        Symbol s = new Symbol(Symbol.Variable, t.image, t.beginLine, t.beginColumn);
        s.setType(type);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);

        if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
        symboltable.addSymbol((yapl.symbol.Symbol)s);

        //symbol 'k' already declared in current scope (as variable)
    }
    ("," u = <ident>
    {
        Symbol v = new Symbol(Symbol.Variable, u.image, u.beginLine, u.beginColumn);
        v.setType(type);
        Symbol checkedSymbol2 = (yapl.symbol.Symbol)symboltable.lookup(u.image, u.beginLine, u.beginColumn);
        if(checkedSymbol2 != null) throw new YAPLException("Identifier '" + u.image + "' already declared in current scope (as " + checkedSymbol2.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, u.beginLine, u.beginColumn);
        symboltable.addSymbol((yapl.symbol.Symbol)v);
    })* ";"
}

void TypeDecl() throws YAPLException:
{
    Token t;
}
{
    "Record" t = <ident>
     {
         Symbol s = new Symbol(Symbol.Typename, t.image, t.beginLine, t.beginColumn);
         s.setType(new RecordType(t.image));
         Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
         if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
         System.out.println("Before adding symbol: " + s.getName());
         symboltable.addSymbol((yapl.symbol.Symbol)s);
         symboltable.openScope(false);
     }
     VarDecl() (VarDecl())* "EndRecord" {symboltable.closeScope();} ";"

}
//________________END OF DECs___________

//________________TYPEs_____________

Type NonArrayType() throws YAPLException:
{
       Token t;
}
{
    "int" {
                return new IntegerType();
        } |
 "bool" {return new BooleanType();} |
    t = <ident> {

                                             Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
                                             Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                                             if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                                              if(checkedSymbol != null){
                                                  if(checkedSymbol.getKindString() != null){
                                                      if(checkedSymbol.getKind() != Symbol.Typename) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                                                  }
                                              }s.setType(checkedSymbol.getType());
                                              symboltable.addSymbol(s);}
                     {return new RecordType(t.image);}
}


Type Type() throws YAPLException:
{
       Type type;
       int length = 0;
}
{
    type = NonArrayType() ("[""]" {length++;})*
    {
    if(length == 0){
        return type;
    } else {
        ArrayType arrayType = new ArrayType();
        arrayType.setTypeOfArray(type);
        arrayType.setLength(length);
        return arrayType;
    }
}
}

Type ReturnType() throws YAPLException:
{
    Type type;
}
{
    "void" {return new VoidType();} | type = Type() {return type;}
}
//________________END OF TYPEs________

//________________PROCEDUREs__________
void Procedure() throws YAPLException:
{
    Token t, endIdent;
    Type  type;
}
{
    "Procedure" type = ReturnType() t = <ident>
    {
        Symbol s = new Symbol(Symbol.Procedure, t.image, t.beginLine, t.beginColumn);
        s.setType(type);
        symboltable.addSymbol(s);
        symboltable.setParentSymbol(s);
        symboltable.openScope(false);
    }
    "(" (FormalParamList())? ")" Block() endIdent = <ident> ";"
    {
        if(!t.image.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match procedure " + t.image, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
    }
}

void FormalParamList() throws YAPLException:
{
}
{
    {System.out.println("Formal Paramlist incoming");}
     FormalParam() ("," FormalParam())*
}

void FormalParam() throws YAPLException:
{
    Token t;
    Type type;
}
{
    type = Type() t = <ident>
    {
                Symbol s = new Symbol(Symbol.Parameter, t.image, t.beginLine, t.beginColumn);
                s.setType(type);
                symboltable.addSymbol((yapl.symbol.Symbol)s);        }
}
//________________END OF PROCEDUREs____

//________________STATEMENTs___________

void StatementList() throws YAPLException:
{
}
{
    (Statement() ";")*
}

void Statement() throws YAPLException:
{
}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() | LOOKAHEAD(2) ProcedureCall() | Block()
}

void WriteStatement() throws YAPLException:
{
}
{
    "Write" <string>
}

void ReturnStatement() throws YAPLException:
{
}
{
    "Return" (Expr())?
}

void WhileStatement() throws YAPLException:
{
}
{
    "While" Expr() "Do" StatementList() "EndWhile"
}

void IfStatement() throws YAPLException:
{
}
{
    "If" Expr() "Then" StatementList() ("Else" StatementList())? "EndIf"
}

void Assignment() throws YAPLException:
{
    Token t, assigner;
    Attrib attrib, selector = null;
}
{
   t = <ident>
   {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        //symbol 'k' already declared in current scope (as variable)
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        if(checkedSymbol.getKind() == (Symbol.Constant)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
        s.setType(checkedSymbol.getType());
        symboltable.addSymbol(s);
   }
   {
        Attrib retAttrib = new Attrib();

    }
   (selector = Selector(retAttrib))? assigner = ":=" attrib = Expr()
   {

    if(attrib.getType() instanceof VoidType) throw new YAPLException("using procedure proc (not a function) in expression", CompilerError.ProcNotFuncExpr, attrib.getLine(), attrib.getColumn());

     System.out.println(checkedSymbol.getType().getClass() + " := " + attrib.getType().getClass());
     if(selector != null){
        if(checkedSymbol.getType() instanceof  ArrayType){
            retAttrib.setType(((ArrayType)checkedSymbol.getType()).getArrayDiff(selector.getType()));
        }
     }else{
        if(checkedSymbol.getType() instanceof  ArrayType){
            retAttrib.setType(((ArrayType)checkedSymbol.getType()).getArrayDiff(((ArrayType)checkedSymbol.getType()).getTypeOfArray()));
        }else{
            retAttrib.setType(checkedSymbol.getType());
        }
     }

     Type type = attrib.getType();// instanceof  ArrayType ? ((ArrayType)attrib.getType()).getArrayDiff(((ArrayType)attrib.getType()).getDeclSymbol().getType()) : attrib.getType();
     System.out.println("Type for assignment: " + type.toString());
     System.out.println("Type for assignment: " + retAttrib.getType().toString());
     if(!yapl.lib.Type.typeIsCompatible(retAttrib.getType(), type)){
         throw new YAPLException("type mismatch in assignment", CompilerError.TypeMismatchAssign, assigner.beginLine, assigner.beginColumn);
     }

     if(checkedSymbol.getType() != attrib.getType()){

     }
}
}

Attrib ProcedureCall() throws YAPLException:
{
    Token t;
}
{
    t = <ident> "(" (ArgumentList())? ")"
    {
            Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
            Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
            //symbol 'k' already declared in current scope (as variable)
            if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
            if(!(checkedSymbol.getKind() == Symbol.Procedure || checkedSymbol.getKind() == Symbol.PredefinedProcedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
            //symboltable.addSymbol(s);
    }
    //TYPECHECKING
    {
        Attrib attrib = new Attrib();
        attrib.setKind((byte)s.getKind());
        //Set type of procedure declaration for comparison when assigning
        attrib.setType(checkedSymbol.getType());
        attrib.setLine(t.beginLine);
        attrib.setColumn(t.beginColumn);
        return attrib;
    }
}

void ArgumentList() throws YAPLException:
{
}
{
    Expr() ("," Expr())*
}

void Block() throws YAPLException:
{
}
{
    {symboltable.openScope(false);}
    (Decl())? "Begin" StatementList() "End"
    {symboltable.closeScope();}
}
//________________END OF STATEMENTs_____

//_______________EXPRESSIONs________

Attrib Expr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    (expr1 = CondAndExpr() (operator = "Or" expr2 = CondAndExpr()
    {
        System.out.println("Type1: " + expr1.getType() + ", Operator: " + operator.image + ", Type2: " + expr2.getType());
        return cg.op2(expr1, operator, expr2);
    }
    )* | expr1 = CreationExpr())
    {
        return expr1;
    }
}

Attrib CreationExpr() throws YAPLException:
{
    Attrib attrib, index = null;
    Type type;
    Token bracket1, bracket2;
    int arrayLength = 0;
}
{
    "new" type = NonArrayType() (bracket1 = "[" index = Expr() bracket2 = "]" {arrayLength++;}
    {
        if(index != null){
                    System.out.println("Index is of type: " + index.getType());
                    if(index.getType() instanceof ArrayType){
                        //if(((ArrayType)index.getType()).getArrayDiff(retAttrib.getType()).getClass() == IntegerType.class) throw new YAPLException("array index or dimension is not an integer type", CompilerError.BadArraySelector, bracket2.beginLine, bracket2.beginColumn);
                    }else{
                        if(index.getType().getClass() != IntegerType.class) throw new YAPLException("array index or dimension is not an integer type", CompilerError.BadArraySelector, bracket2.beginLine, bracket2.beginColumn);
                    }
                    //if(!(yapl.lib.Type.typeIsCompatible(index.getType(), ))) throw new YAPLException("array index or dimension is not an .integer type", CompilerError.BadArraySelector, bracket2.beginLine, bracket2.beginColumn);
                }else{
                    //TODO: check for existing index
                }
    }
    )*
    {
    attrib = new Attrib();
    //Set alternative type if array
    if(arrayLength > 0){
        System.out.println("New array is of length " + arrayLength + " and type '" + type + "'");
        ArrayType t = new ArrayType();
        t.setTypeOfArray(type);
        t.setLength(arrayLength);
        attrib.setType(t);
    }else{
        attrib.setType(type);
    }
    return attrib;
}
}

Attrib CondAndExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = EqualExpr() (operator = "And" expr2 = EqualExpr()
    {
        System.out.println("Type1: " + expr1.getType() + ", Operator: " + operator.image + ", Type2: " + expr2.getType());
        return cg.op2(expr1, operator, expr2);
    }
    )*

    {return expr1;}
}

Attrib EqualExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = RelExpr() (operator = EqualOp() expr2 = RelExpr()
    {
        System.out.println("Type1: " + expr1.getType() + ", Operator: " + operator.image + ", Type2: " + expr2.getType());
        return cg.equalOp(expr1, operator, expr2);
    }
    )?
    {
        return expr1;
    }
}

Attrib RelExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = AddExpr() (operator = RelOp() expr2 = AddExpr()
    {
        System.out.println("Type1: " + expr1.getType() + ", Operator: " + operator.image + ", Type2: " + expr2.getType());
        return cg.relOp(expr1, operator, expr2);
    }
    )?

    {return expr1;}
}

Attrib AddExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = MulExpr() (operator = AddOp() expr2 = MulExpr()
    {
        System.out.println("Type1: " + expr1.getType() + ", Operator: " + operator.image + ", Type2: " + expr2.getType());
        return cg.op2(expr1, operator, expr2);
    }
    )*

    {return expr1;}
}


Attrib MulExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = UnaryExpr() (operator = MulOp() expr2 = UnaryExpr()
    {
        System.out.println("Type1: " + expr1.getType() + ", Operator: " + operator.image + ", Type2: " + expr2.getType());
        return cg.op2(expr1, operator, expr2);
    }
    )*

    {return expr1;}
}

Attrib UnaryExpr() throws YAPLException:
{
   Attrib expr;
   Token operator = null;
}
{
    (operator = AddOp())? expr = PrimaryExpr()
    {
        System.out.print("Type1: " + expr.getType());
        if(operator != null){
            System.out.println(", Operator: " + operator.image);
        }else{
            System.out.println();
        }
        return cg.op1(operator, expr);
    }
}

Attrib PrimaryExpr() throws YAPLException:
{
  Token t;
  Attrib attrib = null, selAttrib = null;
}
{
    attrib = Literal() {return attrib;} | "(" attrib = Expr() ")" {return attrib;} |  LOOKAHEAD (2) (attrib =  ProcedureCall()) {return attrib;} | t = <ident>

    {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        if(checkedSymbol.getKindString() != null){
            if(!(checkedSymbol.getKind() == Symbol.Variable || checkedSymbol.getKind() == Symbol.Constant || checkedSymbol.getKind() == Symbol.Parameter)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " '" + checkedSymbol.getName() + "'", CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
        }
    }

    {
        s.setType(checkedSymbol.getType());
        Attrib symbolattrib = new Attrib();
        symbolattrib.setType(checkedSymbol.getType());
    }

    (selAttrib = Selector(symbolattrib))?

    {
        Attrib retAttrib = new Attrib();
        System.out.println("line: " + t.beginLine);
        retAttrib.setLine(t.beginLine);
        System.out.println("column: " + t.beginColumn);
        retAttrib.setColumn(t.beginColumn);
        Type type = checkedSymbol.getType();

        System.out.println("Checked symbol '" + checkedSymbol.getName() + "' of type: " + checkedSymbol.getType());
        if(selAttrib != null){
            //Check, if symbol before [] is of ArrayType
            if(selAttrib.getType().getClass() == ArrayType.class && checkedSymbol.getType().getClass() != ArrayType.class) throw new YAPLException("expression before '[' is not an array type", CompilerError.SelectorNotArray, t.beginLine, t.beginColumn+1);
            Attrib a = new Attrib();
            a.setType(selAttrib.getType());
            if(selAttrib.getType() instanceof ArrayType) ((ArrayType) selAttrib.getType()).setDeclSymbol(checkedSymbol);
            retAttrib = a;
        }else{
            retAttrib.setType(type);
        }
        return retAttrib;
    }

    | attrib = ArrayLen() {return attrib;}
}

Attrib ArrayLen() throws YAPLException:
{
    Token t, sym;
    Attrib selector = null;
}
{
    sym = "#" t = <ident>
    {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        if(checkedSymbol.getKind() == (Symbol.Constant) || checkedSymbol.getKind() == (Symbol.Procedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
    }
    {
        Attrib retAttrib = new Attrib();
        retAttrib.setType(checkedSymbol.getType());


        if(checkedSymbol.getType() instanceof ArrayType){
            //TODO: check for array level
        }else{
             throw new YAPLException("expression after '#' is not an array type", CompilerError.ArrayLenNotArray, sym.beginLine, sym.beginColumn);
        }
    }
    (selector = Selector(retAttrib))?
    {
        if(selector != null){

        }

        return retAttrib;
    }

}

Attrib Selector(Attrib retAttrib) throws YAPLException:
{
    Attrib attrib, index = null, selector = null;
    Token token = null, bracket1 = null, bracket2 = null;
}
{
    ( bracket1 = "[" index = Expr()  bracket2 = "]" | "." token = <ident> ) (selector = Selector(retAttrib))?
    {
    attrib = new Attrib();

    if(token != null){
        Symbol s = new Symbol(token.kind, token.image, token.beginLine, token.beginColumn);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(token.image, token.beginLine, token.beginColumn);
        if(checkedSymbol == null) throw new YAPLException("identifier '" + token.image + "' not declared", CompilerError.IdentNotDecl, token.beginLine, token.beginColumn);

        s.setType(checkedSymbol.getType());

        if(selector == null){
            attrib.setType(checkedSymbol.getType());
        }else{
            ArrayType at = new ArrayType();
            at.setLength(selector.getType() instanceof ArrayType ? ((ArrayType)selector.getType()).getLength() : 1);
            at.setTypeOfArray(selector.getType());
            attrib.setType(at);
        }
    }else{
        //Throw new error if indey.type != IntegerType
        if(index != null){
            System.out.println("Index is of type: " + index.getType());
            if(index.getType() instanceof ArrayType){
                if(((ArrayType)index.getType()).getArrayDiff(retAttrib.getType()).getClass() == IntegerType.class) throw new YAPLException("array index or dimension is not an integer type", CompilerError.BadArraySelector, bracket2.beginLine, bracket2.beginColumn);
            }else{
                if(index.getType().getClass() != IntegerType.class) throw new YAPLException("array index or dimension is not an integer type", CompilerError.BadArraySelector, bracket2.beginLine, bracket2.beginColumn);
            }
            //if(!(yapl.lib.Type.typeIsCompatible(index.getType(), ))) throw new YAPLException("array index or dimension is not an .integer type", CompilerError.BadArraySelector, bracket2.beginLine, bracket2.beginColumn);
        }else{
            //TODO: check for existing index
        }

        if(selector == null){
            ArrayType at = new ArrayType();
            at.setLength(1);
            at.setTypeOfArray(retAttrib.getType());
            attrib.setType(at);
        }else{
            ArrayType at = new ArrayType();
            at.setLength(((ArrayType)selector.getType()).getLength());
            at.setTypeOfArray(selector.getType());
            attrib.setType(at);
        }
    }
    return attrib;
}
}

Attrib Literal() throws YAPLException:
{
       Attrib attrib;
       Token t;
}
{
    t = "True" {return new Attrib(new BooleanType(true), t.beginLine, t.beginColumn);} | t = "False" {return new Attrib(new BooleanType(false), t.beginLine, t.beginColumn);} | t = <number> {return new Attrib(new IntegerType(), t.beginLine, t.beginColumn);}
}
//_______________END OF EXPRESSIONs____

//__________________OPs_______________
Token RelOp() throws YAPLException:
{
    Token token;
}
{
    (token = "<" | token = "<=" | token = ">=" | token = ">")
    {
        return token;
    }
}

Token EqualOp() throws YAPLException:
{
    Token token;
}
{
    (token = "==" | token = "!=")
    {
        return token;
    }
}

Token AddOp() throws YAPLException:
{
     Token token;
}
{
    (token = "+" | token = "-")
    {
       return token;
    }
}

Token MulOp() throws YAPLException:
{
            Token token;
}
{
    (token = "*" | token = "/" | token = "%")
    {
            return token;
        }
}
//________________END OF OPs___________


TOKEN : /* LITERALS */
{

    <ident: <letter> ( <letter> | <digit> )*>
|
    <number: <digit> ( <digit> )*>
|
    <string:"\"" ( " " | <letter> | <digit> | <otherchar> )* "\"">
|
     <digit: ["0"-"9"] >
|
    <letter: ["A"-"Z"]|["a"-"z"]|"_">
|
    <otherchar:"+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
                         | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
                         | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|">
}
