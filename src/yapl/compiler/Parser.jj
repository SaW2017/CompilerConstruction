options {
    LOOKAHEAD = 1;
    DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Parser)
package yapl.compiler;
import yapl.interfaces.CompilerError;
import yapl.lib.CompilerMessage;
import java.io.FileInputStream;
import java.io.FileNotFoundException;import java.lang.reflect.Array;
import yapl.symbol.*;
import yapl.lib.*;

/** CA2.3 */
public class Parser {

    private static String programName = "";
    private static Symboltable symboltable = new Symboltable();
    private static CodeGen cg = new CodeGen();

  /** Main entry point. */
  public static void main(String args[]) {

        if(args.length < 1){
            System.out.println("Not enough arguments! Please enter file path.");
            return;
        }
        try{
            Parser parser = new Parser(new FileInputStream(args[0]));
            parser.Program();
            CompilerMessage.printOK(programName);
        } catch (ParseException e) {
            CompilerMessage.printError(e, programName);
        } catch(TokenMgrError e) {
            CompilerMessage.printError(e, programName);
        }catch (YAPLException e){
            CompilerMessage.printError(e, programName);
        } catch(Exception e){
            e.printStackTrace();
        }
   }
}

PARSER_END(Parser)

/*
#################################
###### TYPE CHECKING ORDER ######
#################################

1) Expressions
2) Assignments
3) Procedure Declarations
4) Procedure Calls
5) Other Statements



 */


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN : /* COMMENTS */
{
 <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

void Program() throws YAPLException:
{
        Token t, endIdent;
}
{
    {
        symboltable.openScope(true);

        Symbol pp1 = new Symbol(Symbol.PredefinedProcedure, "writeint", 0, 0);
                Symbol pp1p = new Symbol(Symbol.Parameter, "i", 0, 0);

                Symbol pp2 = new Symbol(Symbol.PredefinedProcedure, "writebool", 0, 0);
                Symbol pp2p = new Symbol(Symbol.Parameter, "b", 0, 0);

                Symbol pp3 = new Symbol(Symbol.PredefinedProcedure, "writeln", 0, 0);

                Symbol pp4 = new Symbol(Symbol.PredefinedProcedure, "readint", 0, 0);

                symboltable.addSymbol(pp1);
                symboltable.addSymbol(pp1p);
                symboltable.addSymbol(pp2);
                symboltable.addSymbol(pp2p);
                symboltable.addSymbol(pp3);
                symboltable.addSymbol(pp4);
    }
    "Program" t = <ident>
    {
        symboltable.openScope(true);

        Symbol s = new Symbol(Symbol.Program, t.image, t.beginLine, t.beginColumn);
        symboltable.setParentSymbol(s);
        symboltable.addSymbol(s);
        programName = t.toString();
        symboltable.openScope(true);

    }
    ( Decl() | Procedure())*
    "Begin"  StatementList() "End" endIdent = <ident>
    {
        if(!programName.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match program " + programName, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
        symboltable.closeScope();
    }
    "." <EOF>


}


//Decls
void Decl() throws YAPLException:
{
}
{
    "Declare" ( ConstDecl() | VarDecl() | TypeDecl() ) *
}

void ConstDecl() throws YAPLException:
{
     Token t;
     Attrib attrib;
}
{
    "Const" t = <ident> "=" attrib = Literal() ";"
    {
        Symbol s = new Symbol(Symbol.Constant, t.image, t.beginLine, t.beginColumn);
        s.setType(attrib.getType());
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
        if(checkedSymbol != null) {
            throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
        }
        symboltable.addSymbol((yapl.symbol.Symbol)s);
        }
}

void VarDecl() throws YAPLException:
{
    Token t, u;
    Type type;
}
{
    type = Type() t = <ident>
    {
        Symbol s = new Symbol(Symbol.Variable, t.image, t.beginLine, t.beginColumn);
        s.setType(type);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);

        if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
        symboltable.addSymbol((yapl.symbol.Symbol)s);

        //symbol 'k' already declared in current scope (as variable)
    }
    ("," u = <ident>
    {
        Symbol v = new Symbol(Symbol.Variable, u.image, u.beginLine, u.beginColumn);
        Symbol checkedSymbol2 = (yapl.symbol.Symbol)symboltable.lookup(u.image, u.beginLine, u.beginColumn);
        if(checkedSymbol2 != null) throw new YAPLException("Identifier '" + u.image + "' already declared in current scope (as " + checkedSymbol2.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, u.beginLine, u.beginColumn);
        symboltable.addSymbol((yapl.symbol.Symbol)v);
    })* ";"
}

void TypeDecl() throws YAPLException:
{
    Token t;
}
{
    "Record" t = <ident>
     {
         Symbol s = new Symbol(Symbol.Typename, t.image, t.beginLine, t.beginColumn);
         s.setType(new RecordType(t.image));
         Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.getSymbolFromCurrentScope(t.image);
         if(checkedSymbol != null) throw new YAPLException("Identifier '" + t.image + "' already declared in current scope (as " + checkedSymbol.getKindString().toLowerCase() + ")", CompilerError.SymbolExists, t.beginLine, t.beginColumn);
         System.out.println("Before adding symbol: " + s.getName());
         symboltable.addSymbol((yapl.symbol.Symbol)s);
         symboltable.openScope(false);
     }
     VarDecl() (VarDecl())* "EndRecord" {symboltable.closeScope();} ";"

}
//________________END OF DECs___________

//________________TYPEs_____________

Type NonArrayType() throws YAPLException:
{
       Token t;
}
{
    "int" {
                return new IntegerType();
        } |
 "bool" {return new BooleanType();} |
    t = <ident> {

                                             Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
                                             Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
                                             System.out.println("Lookup finished");
                                             if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
                                              if(checkedSymbol != null){
                                                  if(checkedSymbol.getKindString() != null){
                                                      if(checkedSymbol.getKind() != Symbol.Typename) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
                                                  }
                                              }symboltable.addSymbol(s);}
                     {return new RecordType(t.image);}
}


Type Type() throws YAPLException:
{
       Type type;
}
{
    type = NonArrayType() ("[""]")*
    {return type;}
}

Type ReturnType() throws YAPLException:
{
    Type type;
}
{
    "void" {return new VoidType();} | type = Type() {return type;}
}
//________________END OF TYPEs________

//________________PROCEDUREs__________
void Procedure() throws YAPLException:
{
    Token t, endIdent;
    Type  type;
}
{
    "Procedure" type = ReturnType() t = <ident>
    {
        Symbol s = new Symbol(Symbol.Procedure, t.image, t.beginLine, t.beginColumn);
        s.setType(type);
        symboltable.addSymbol(s);
        symboltable.setParentSymbol(s);
        symboltable.openScope(false);
    }
    "(" (FormalParamList())? ")" Block() endIdent = <ident> ";"
    {
        if(!t.image.equals(endIdent.image)) throw new YAPLException("End " + endIdent.image + " does not match procedure " + t.image, CompilerError.EndIdentMismatch, endIdent.beginLine, endIdent.beginColumn);
        symboltable.closeScope();
    }
}

void FormalParamList() throws YAPLException:
{
}
{
    {System.out.println("Formal Paramlist incoming");}
     FormalParam() ("," FormalParam())*
}

void FormalParam() throws YAPLException:
{
    Token t;
    Type type;
}
{
    type = Type() t = <ident>
    {
                Symbol s = new Symbol(Symbol.Parameter, t.image, t.beginLine, t.beginColumn);
                s.setType(type);
                symboltable.addSymbol((yapl.symbol.Symbol)s);        }
}
//________________END OF PROCEDUREs____

//________________STATEMENTs___________

void StatementList() throws YAPLException:
{
}
{
    (Statement() ";")*
}

void Statement() throws YAPLException:
{
}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() | LOOKAHEAD(2) ProcedureCall() | Block()
}

void WriteStatement() throws YAPLException:
{
}
{
    "Write" <string>
}

void ReturnStatement() throws YAPLException:
{
}
{
    "Return" (Expr())?
}

void WhileStatement() throws YAPLException:
{
}
{
    "While" Expr() "Do" StatementList() "EndWhile"
}

void IfStatement() throws YAPLException:
{
}
{
    "If" Expr() "Then" StatementList() ("Else" StatementList())? "EndIf"
}

void Assignment() throws YAPLException:
{
    Token t;
    Attrib attrib;
}
{
   t = <ident>
   {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        //symbol 'k' already declared in current scope (as variable)
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        if(checkedSymbol.getKind() == (Symbol.Constant)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
        symboltable.addSymbol(s);
   }
   {
        Attrib retAttrib = new Attrib();
        retAttrib.setType(checkedSymbol.getType());
    }
   (Selector(retAttrib))? ":=" attrib = Expr()
   {

        System.out.println(attrib.getType().getClass() + ", " + checkedSymbol.getType().getClass());
        if(attrib.getType() instanceof VoidType) throw new YAPLException("using procedure proc (not a function) in expression", CompilerError.ProcNotFuncExpr);
        if(checkedSymbol.getType() != attrib.getType()){
            
        }
   }
}

Attrib ProcedureCall() throws YAPLException:
{
    Token t;
}
{
    t = <ident> "(" (ArgumentList())? ")"
    {
            Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
            Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
            //symbol 'k' already declared in current scope (as variable)
            if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
            if(!(checkedSymbol.getKind() == Symbol.Procedure || checkedSymbol.getKind() == Symbol.PredefinedProcedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
            //symboltable.addSymbol(s);
    }
    //TYPECHECKING
    {
        Attrib attrib = new Attrib();
        attrib.setKind((byte)s.getKind());
        //Set type of procedure declaration for comparison when assigning
        attrib.setType(checkedSymbol.getType());
        return attrib;
    }
}

void ArgumentList() throws YAPLException:
{
}
{
    Expr() ("," Expr())*
}

void Block() throws YAPLException:
{
}
{
    {symboltable.openScope(false);}
    (Decl())? "Begin" StatementList() "End"
    {symboltable.closeScope();}
}
//________________END OF STATEMENTs_____

//_______________EXPRESSIONs________

Attrib Expr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    (expr1 = CondAndExpr() ("Or" expr2 = CondAndExpr()
    {
        operator = new Token();
        operator.image = "Or";
        return cg.op2(expr1, token, expr2);
    }
    )* | expr1 = CreationExpr())
    {
        return expr1;
    }
}

Attrib CreationExpr() throws YAPLException:
{
    Attrib attrib;
    Type type;
    int arrayLength = 0;
}
{
    "new" type = NonArrayType() ("[" Expr() "]" {arrayLength++;})*
    {
    attrib = new Attrib();
    //Set alternative type if array
    if(arrayLength > 0){
        ArrayType t = new ArrayType();
        t.setArrayType(type);
        t.setLength(arrayLength);
        attrib.setType(t);
    }else{
        attrib.setType(type);
    }
    return attrib;
}
}

Attrib CondAndExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = EqualExpr() ("And" expr2 = EqualExpr()
    {
        operator = new Token();
        operator.image = "And";
        return cg.op2(expr1, token, expr2);
    }
    )*

    {return expr1;}
}

Attrib EqualExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    (expr1 = RelExpr() (operator = EqualOp() expr2 = RelExpr()
    {
        return cg.equalOp(expr1, operator, expr2);
    }
    )?)
    {
        return expr1;
    }
}

Attrib RelExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = AddExpr() (operator = RelOp() expr2 = AddExpr()
    {
        return cg.relOp(expr1, operator, expr2);
    }
    )?

    {return expr1;}
}

Attrib AddExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = MulExpr() (operator = AddOp() expr2 = MulExpr()
    {
        return cg.op2(expr1, operator, expr2);
    }
    )*

    {return expr1;}
}


Attrib MulExpr() throws YAPLException:
{
    Attrib expr1, expr2;
    Token operator;
}
{
    expr1 = UnaryExpr() (operator = MulOp() expr2 = UnaryExpr()
    {
        return cg.op2(expr1, operator, expr2);
    }
    )*

    {return expr1;}
}

Attrib UnaryExpr() throws YAPLException:
{
   Attrib expr;
   Token operator = null;
}
{
    (operator = AddOp())? expr = PrimaryExpr()
    {
        return cg.op1(operator, expr);
    }
}

Attrib PrimaryExpr() throws YAPLException:
{
  Token t;
  Attrib attrib = null, selAttrib = null;
}
{
    attrib = Literal() {return attrib;} | "(" attrib = Expr() ")" {return attrib;} |  LOOKAHEAD (2) (attrib =  ProcedureCall()) {return attrib;} | t = <ident>

    {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);

        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        System.out.println("Symbol to check: " + t.image + " of kind: " + t.kind);
        System.out.println("Checked symbol: " + checkedSymbol.getName());
        if(checkedSymbol.getKindString() != null){
            if(!(checkedSymbol.getKind() == Symbol.Variable || checkedSymbol.getKind() == Symbol.Constant || checkedSymbol.getKind() == Symbol.Parameter)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " '" + checkedSymbol.getName() + "'", CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
        }
    }
    {
        Attrib retAttrib = new Attrib();
        Type t = checkedSymbol.getType();
        if(t instanceof ArrayType) {
            t = new ArrayType();
            ((ArrayType)t).setDeclSymbol(checkedSymbol);
        }
        retAttrib.setType(t);
    }

    (selAttrib = Selector(retAttrib))?

    {
        if(selAttrib != null){
            Attrib a = new Attrib();
            a.setType(selAttrib.getType());
            retAttrib = a;
        }
        return retAttrib;
    }

    | ArrayLen() {return attrib;}
}

void ArrayLen() throws YAPLException:
{
Token t;
}
{
    "#" t = <ident>
    {
        Symbol s = new Symbol(t.kind, t.image, t.beginLine, t.beginColumn);
        System.out.println("Kind: " + t.kind);
        Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(t.image, t.beginLine, t.beginColumn);
        if(checkedSymbol == null) throw new YAPLException("identifier '" + t.image + "' not declared", CompilerError.IdentNotDecl, t.beginLine, t.beginColumn);
        if(checkedSymbol.getKind() == (Symbol.Constant) || checkedSymbol.getKind() == (Symbol.Procedure)) throw new YAPLException("illegal use of " + checkedSymbol.getKindString().toLowerCase() + " " + checkedSymbol.getName(), CompilerError.SymbolIllegalUse, t.beginLine, t.beginColumn);
    }
    {
        Attrib retAttrib = new Attrib();
        retAttrib.setType(checkedSymbol.getType());
    }
    (Selector(retAttrib))?
}

Attrib Selector(Attrib retAttrib) throws YAPLException:
{
    Attrib attrib, index, selector = null;
    Token token = null;
}
{
    ( "[" index = Expr()  "]" | "." token = <ident> ) (selector = Selector(retAttrib))?
    {
        attrib = new Attrib();

        if(token != null){
            Symbol s = new Symbol(token.kind, token.image, token.beginLine, token.beginColumn);
            Symbol checkedSymbol = (yapl.symbol.Symbol)symboltable.lookup(token.image, token.beginLine, token.beginColumn);
            if(checkedSymbol == null) throw new YAPLException("identifier '" + token.image + "' not declared", CompilerError.IdentNotDecl, token.beginLine, token.beginColumn);

            if(selector == null){
                attrib.setType(checkedSymbol.getType());
            }else{
                ArrayType at = new ArrayType();
                at.setLength(((ArrayType)selector.getType()).getLength());
                at.setArrayType(selector.getType());
                attrib.setType(at);
            }
        }else{
            if(selector == null){
                ArrayType at = new ArrayType();
                at.setLength(1);
                at.setArrayType(retAttrib.getType());
                attrib.setType(at);
            }else{
                ArrayType at = new ArrayType();
                at.setLength(((ArrayType)selector.getType()).getLength());
                at.setArrayType(selector.getType());
                attrib.setType(at);
            }
        }
        return attrib;
    }
}

Attrib Literal() throws YAPLException:
{
       Attrib attrib;
}
{
    "True" {return new Attrib(new BooleanType());} | "False" {return new Attrib(new BooleanType());} | <number> {return new Attrib(new IntegerType());}
}
//_______________END OF EXPRESSIONs____

//__________________OPs_______________
Token RelOp() throws YAPLException:
{
    Token token;
}
{
    (token = "<" | token = "<=" | token = ">=" | token = ">")
    {
        return token;
    }
}

Token EqualOp() throws YAPLException:
{
    Token token;
}
{
    (token = "==" | token = "!=")
    {
        return token;
    }
}

Token AddOp() throws YAPLException:
{
     Token token;
}
{
    (token = "+" | token = "-")
    {
       return token;
    }
}

Token MulOp() throws YAPLException:
{
            Token token;
}
{
    (token = "*" | token = "/" | token = "%")
    {
            return token;
        }
}
//________________END OF OPs___________


TOKEN : /* LITERALS */
{

    <ident: <letter> ( <letter> | <digit> )*>
|
    <number: <digit> ( <digit> )*>
|
    <string:"\"" ( " " | <letter> | <digit> | <otherchar> )* "\"">
|
     <digit: ["0"-"9"] >
|
    <letter: ["A"-"Z"]|["a"-"z"]|"_">
|
    <otherchar:"+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
                         | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
                         | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|">
}
