options {
    LOOKAHEAD = 2;
    DEBUG_TOKEN_MANAGER = true;
    MULTI = true;
}

PARSER_BEGIN(Parser)
package yapl.compiler;
import yapl.Symboltable;import yapl.interfaces.CompilerError;
import yapl.interfaces.Symbol;import yapl.lib.CompilerMessage;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

/** CA3 */
public class Parser {

    private static String programName = "";
    private static Symboltable st = new Symboltable();

  /** Main entry point. */
  public static void main(String args[]) {
    //https://www.cs.purdue.edu/homes/hosking/javacc/doc/JJTree.html
        if(args.length < 1){
            System.out.println("Not enough arguments! Please enter file path.");
            return;
        }
        try{
            Parser parser = new Parser(new FileInputStream(args[0]));
            ASTProgram astProgramRoot = null;
            astProgramRoot = parser.Program();
            astProgramRoot.dump("AST: ");

            System.out.println("--> " + astProgramRoot.getProgramName());
            System.out.println("--->" + astProgramRoot.jjtGetNumChildren());
            for(int i = 0 ; i < astProgramRoot.jjtGetNumChildren(); i++){
                System.out.println("C -> " + ((SimpleNode)astProgramRoot.jjtGetChild(i)).getProgramName());
            }

            CompilerMessage.printOK(programName);
        } catch (ParseException e) {
            CompilerMessage.printError(e, programName);
        } catch(TokenMgrError e) {
            CompilerMessage.printError(e, programName);
        } catch(Exception e){
            e.printStackTrace();
        }


   }



}

PARSER_END(Parser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

SPECIAL_TOKEN :
{
 <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

ASTProgram Program():
{
        Token t;
}
{
    //"Program" t = <ident> {  programName = t.toString();} ( Decl() | Procedure())*
    //"Begin" StatementList() "End" <ident> "." <EOF>

    "Program" t = <ident> { jjtThis.setName(t.image);  jjtThis.setIdent(t.image); jjtThis.setKind(Symbol.Program);} ( Decl() | Procedure() )*
              "Begin" StatementList() "End" End(t.image)
        {
            return jjtThis;
        }

}


ASTEnd End(String program):
{
    Token t;
}
{
    t = <ident> { jjtThis.setName(t.image); jjtThis.setProgramName(program);} "." <EOF>
    {
        return jjtThis;
    }
}


//Decls
void Decl():
{
}
{
    "Declare" ( ConstDecl() | VarDecl() | TypeDecl())*
}

void ConstDecl():
{
}
{
    "Const" <ident> "=" Literal() ";"
}

void VarDecl():
{
}
{
    Type() <ident> ("," <ident>)* ";"
}

void TypeDecl():
{
}
{
    "Record" <ident> VarDecl() (VarDecl())* "EndRecord" ";"
}
//________________END OF DECs___________

//________________TYPEs_____________

void NonArrayType():
{
}
{
    "int" | "bool" | <ident>
}

void Type():
{
}
{
    NonArrayType() ("[""]")*
}

void ReturnType():
{
}
{
    "void" | Type()
}
//________________END OF TYPEs________

//________________PROCEDUREs__________
void Procedure():
{
}
{
    "Procedure" ReturnType() <ident> "(" (FormalParamList())? ")" Block() <ident> ";"
}

void FormalParamList():
{
}
{
    FormalParam() ("," FormalParam())*
}

void FormalParam():
{
}
{
    Type() <ident>
}
//________________END OF PROCEDUREs____

//________________STATEMENTs___________

void StatementList():
{
}
{
    (Statement() ";")*
}

void Statement():
{
}
{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | Assignment() | ProcedureCall() | Block()
}

void WriteStatement():
{
}
{
    "Write" <string>
}

void ReturnStatement():
{
}
{
    "Return" (Expr())?
}

void WhileStatement():
{
}
{
    "While" Expr() "Do" StatementList() "EndWhile"
}

void IfStatement():
{
}
{
    "If" Expr() "Then" StatementList() ("Else" StatementList())? "EndIf"
}

void Assignment():
{
}
{
    <ident> (Selector())? ":=" Expr()
}

void ProcedureCall():
{
}
{
    <ident> "(" (ArgumentList())? ")"
}

void ArgumentList():
{
}
{
    Expr() ("," Expr())*
}

void Block():
{
}
{
    (Decl())? "Begin" StatementList() "End"
}
//________________END OF STATEMENTs_____

//_______________EXPRESSIONs________

void Expr():
{
}
{
    CondAndExpr() ("Or" CondAndExpr())* | CreationExpr()
}

void CreationExpr():
{
}
{
    "new" NonArrayType() ("[" Expr() "]")*
}

void CondAndExpr():
{
}
{
    EqualExpr() ("And" EqualExpr())*
}

void EqualExpr():
{
}
{
    RelExpr() (EqualOp() RelExpr())?
}

void RelExpr():
{
}
{
    AddExpr() (RelOp() AddExpr())?
}

void AddExpr():
{
}
{
    MulExpr() (AddOp() MulExpr())*
}


void MulExpr():
{
}
{
    UnaryExpr() (MulOp() UnaryExpr())*
}

void UnaryExpr():
{
}
{
    (AddOp())? PrimaryExpr()
}

void PrimaryExpr():
{
}
{
    Literal() | "(" Expr() ")" | ProcedureCall() | <ident> (Selector())? | ArrayLen()
}

void ArrayLen():
{
}
{
    "#" <ident> (Selector())?
}

void Selector():
{
}
{
    ( "[" Expr()  "]" | "." <ident> ) (Selector())?
}

void Literal():
{
}
{
    "True" | "False" | <number>
}
//_______________END OF EXPRESSIONs____

//__________________OPs_______________
void RelOp():
{
}
{
    "<" | "<=" | ">=" | ">"
}

void EqualOp():
{
}
{
    "==" | "!="
}

void AddOp():
{
}
{
    "+" | "-"
}

void MulOp():
{
}
{
    "*" | "/" | "%"
}
//________________END OF OPs___________


TOKEN : /* LITERALS */
{

    <ident: <letter> ( <letter> | <digit> )*>
|
    <number: <digit> ( <digit> )*>
|
    <string:"\"" ( " " | <letter> | <digit> | <otherchar> )* "\"">
|
     <digit: ["0"-"9"] >
|
    <letter: ["A"-"Z"]|["a"-"z"]|"_">
|
    <otherchar:"+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!"
                         | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")"
                         | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|">
}
